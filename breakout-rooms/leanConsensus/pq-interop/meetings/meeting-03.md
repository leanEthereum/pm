# PQ Interop - Meeting 03

## Meeting Overview
**Date:** July 30, 2025
**Agenda:** https://github.com/ethereum/pm/issues/1635
**Recording:** Not recorded, by mistake

---
## Meeting Notes

- **PQ DevNet-0 Specification Updates**: Discussed open items including peer discovery (static bootstrap peers proposed), block size concerns with attestations (proceed with inclusion, full 3SF for simplicity); suggestion for "trust me bro" placeholder data in blocks to simulate snark sizes without real proofs.
- **Fork Choice Spec**: Debated full 3SF vs. mini (LMD GWill only, no justification/finality); agreed to use mini for DevNet-0 with modifications (e.g., Genesis at slot 0), assuming external signature validation; plan to collaborate on SSZ structures.
- **Kurtosis and Genesis Support**: Explored primitive Kurtosis needs for DevNet-0 (Genesis generator with validator key references, no private keys yet); Barnabas/PandaOps for help; no existing tools for custom keys, so adapt normal generator or create simple format.
- **Serialization**: Confirmed use of existing SSZ for types/containers; teams to discuss and align on final structures.
- **Communication Channels**: Agreed to consolidate Telegram groups, create Discord bridge for cross-posting to EF R&D Discord (post-quantum channel), deprecating old groups.
- **Broader Outcomes**: Brief crypto/spec repo update (koala bear merged, Poseidon2 next); aim for fast iteration on minimal spec.

**Action Items**:
- Offline discussion on block attestation inclusion and 3SF mini modifications (Ream/Zeam).
- Collaborate on SSZ types/containers and lean spec repo (Felipe/Tamaghna with teams).
- Engage Barnabas/PandaOps for Kurtosis/Genesis generator support; discuss gaps (Gajinder/Barnabas).
- Set up Discord channel and Telegram-Discord bridge; deprecate old Telegram groups (Will).
- Circulate meeting minutes and prepare for next call agenda, including unresolved spec items.

---
## Meeting Transcript

### PQ DevNet-0 Spec Discussion

**Will:** Alright. So we're gonna try to keep the call at thirty minutes so people can join the the livestream. Happy birthday, Ethereum. First and foremost. So let's just jump in I've I added a note here just to start talking about the PQ DevNet zero spec. Not quite sure if there's any open conversations I had flagged Grapebaba, you had noted that there was a a missing discovery session section. With a proposal for static bootstrap peers And then Kamil and O, there was a discussion that you had, I believe, that was ongoing about block size and and block slot. Duration. O, you you were really involved in commenting on the spec. I don't know if there's anything that you wanted to jump in by I guess, that you feel is, an open item remaining on that?

**O (Ream):** Yeah. Yeah. On the the block size from the like, including the attestations into the block, I think that's just my kind of, like, early observation that it might be pretty big for the network. For the First DevNet. But I think, like, we can we can take this offline. And, also, I don't think we do need to change anything. I think we can just, like, go with, like, including the attestations inside the block. And then, you know, once it really slows us down, then then we can update otherwise. Like, I think sticking to if we agree to to use 3SF, sticking to to 3SF would be ideal. I think.

**Will:** Okay. Kamil.

**Kamil:** Yeah. Just maybe a stupid idea, but maybe just instead of including all attestations, which is, like, all signatures, which is quite costly, we can instead include 128 kilobyte string or some data just basically saying that, trust me, bro. I basically all the signatures and prove them. So it's that's kinda then in future, it would be very easy to kinda replace this verify functions that checking this string with real snark proof verification. And kinda like that. I don't know. But, yeah, it's kinda assumption that yeah, we're basically throwing some data that is not actually it's basically some fake data. It's not real, snark or something.

**Will:** Right.

**Kamil:** But it's closer in terms of size of the message that we can expect and to what we actually include into the block. It's it's closer to the real scenario. In that sense.

**Will:** Thanks. Gajinder, anything you wanna

**Gajinder (Zeam):** So good idea, Kamil. But since we will be running DevNet in small cluster. Right? So might just be located inside a single facility. So mean, we should not really worry about the sizes as of now. Maybe, you know, we have 100 validators, if not thousand validators. DevNet zero. The point of DevNet zero is not to basically benchmark too much, but to deal with the real things and sort DevNet zero's DevNet one. To deal with the real things and just, you know, get things going. So I think these these are the things that we can worry about later. And when that and the next step will be aggregation. So might we might not even end up worrying about that. And we might actually want to experience at that point that what happens in a real network. So I don't think we should just have some ad hoc signatures that the point of this time not just to test signatures. So we shouldn't be doing that. Even though we can definitely scale the amount of traffic with regard to we can test. But even on a single cluster, in a single facility, which we shouldn't worry too much.

### Fork Choice Spec Discussion

**Will:** Okay. Great. Makes sense.

**Gajinder:** Yeah I guess. Oh, on 3SF, Maybe I'm naive, but LMD gWill and 3SF mini. Plus proposing block plus voting. I think is almost everything is there in 3SF. The remaining justification finalization logic is quite small. So if that

**Will:** Yeah. So so just to expand

**Gajinder:** to expand on the vendor whether, like, we're gonna do, like, entire 3SF or a a trim of it. Going with just the full 3SF might be easier. So because we we already have the reference implementation. Right? So we can all all implement right away rather than, like, trying to come up with a a a a trimmed out specs or implementation. Oh, I I think Gajinder says Gajinder said. Good with this. So but unless maybe maybe Jin or Jihoon might wanna chime in, or do you agree? Hi, Justin. So Yeah. So 3SF mini has a quite clear spec, and, also, we have Python code, So I think it is very good place to start. But one thing I'd I'd like to notice is that it doesn't have, signature validation or something. So we need to figure out how we can integrate the signatures in the current containers like vote or state. So just to chime in over here. So the 3SF mini that Vitalik has there there will be some modifications that will need on top of it. For example, handling of the Genesis block because in 3SF mini, Genesis is slot one while we generally have Genesis as slot zero. So small additional logic or additional logic that we handle while processing slot one or, basically, the first block. So apart from that, I think we can just adopt it. With regard to signatures, we so, generally, what really happens is that we can basically pass a flag in in the state transition function that says that's the next signatures have been externally validated, which is basically how we will do it because the state transition function will need to be provable. And so is basically running outside the signature aggregation slash proving verification mode there. Basically, those are separately verified and proved. So so, basically, what I'm saying is that we don't have too much about signature validation inside the 3SF. We'll basically there we should assume that there will be a separate validation that will run before block processing starts. For all the signatures that are in the block the block signature as well as attestation signatures or forward, signatures that might be there or for slashing, etcetera. So apart from that, I think we don't really need to worry too much about signature on the DevNet zero, but then DevNet one will have the signature bit into it. So signature will start coming in coming over the role coming into picture over there.

**Will:** Two in a row. Anything to add to that? Are you guys good with that direction?

### Kurtosis Support Discussion

**Will:** Barnabas, welcome. I see your question. I was actually just noting that we had some open discussion items on this first DevNet spec, I was gonna see if we should get some ETH PandaOps people to join this next call, but you're asking for a TLDR on what's needed for primitive Kurtosis support. You front row. O or Gajinder, maybe could one of you speak to Kurtosis support?

**Gajinder:** I speak a little bit about it. I think the most primitive thing that will need will be Genesis generator, and the Genesis generator will also need to have the validator keys generated inside it. So zero, obviously, then validated a key generator is not really the concern. But we will basically still generate the Genesis with with that tool and be so, basically, allocate some key references to it at least. Like public key references to it so that validators can be distributed among the nodes. And I then what Kurtosis needs to do is basically spin up spin up the nodes with some delay. And I think that's about it because we don't have any execution linked to it right now. So it will be, like, how phase zero of Beacon chain progressed. And there will be no deposits, etcetera. So all that is something that we don't need to worry about. What kind of keys do you need? Baked into the Genesis? We will just need some key references. I mean, the just be so what we need is that when we will define the Genesis state, it will have some validators array, and each validator will have a pub key hex to it and is actually no need of key public private key over there. It's just a random that you can generate, and so those hex can be distributed among different validator nodes so the so that they just figure out that, okay, you know, I'm validator x, validator one, or validator two or whatever. And, basically, then do their duties according to that. Apart from that, because on DevNet zero, we don't need it. Then on DevNet one, will need to integrate public private key generator will, I think, be quite CPU intensive task. Generate the keys. And that will sort of generate the private keys. And for that, we will also come up with a simple spec of how to generate the key file. Which will not be similar to which will be very different from the beacon key file. Do we need Dora support? I guess we have Dora support. But I don't know But what things we need to sounds like quite some work, to be honest, especially if the evaluator key structure is gonna be different. Because right now, we assume that everything is a BLS key, basically. So Yes. The whole library different libraries. You have multiple libraries that we require to update for this. So yeah, the only way I can see it happening is if you would have a new library that supports this new character key structure, we would add support for basically, picking and choosing whether we want lean Ethereum or a normal Ethereum like, these are keys at polygenesis validator sets. Or we completely Ethereum package, and we work off of that. But yeah, I'm not sure. What what's the best approach is. Yeah. I mean as long as everyone aware about like every other peers then yeah, I think this will work. Yeah. So everyone could still be aware about each other peers and still do some sort of a topology so basically not have a star topology that I think gossip will anyway take care of. So yeah, as you mentioned that if basically the information is there, the should be able to form a good network. Okay. Thanks.

**Barnabas:** Yeah I mean as long as everyone aware about like every other peers then yeah, I think this will work.

**Gajinder:** Yeah, so everyone could still be aware about each other peers and still do some sort of a topology so basically not have a star topology that I think gossip will anyway take care of. So yeah, as you mentioned that if basically the information is there, the should be able to form a good network. Okay. Thanks.

### Spec Repo Updates

**Will:** Alright. So we glossed over item two, which was the fork choice spec discussion. I don't know if there's anything else that needs to be said there. There were I woke up I saw some conversation debating over which direction to go Do people have clarity on that Oh, sorry. Oh, on three s f, Maybe I'm naive, but LMD gWill and three s f mini. Plus proposing block plus voting. I think is almost everything is there in three SF. The remaining justification finalization logic is quite small. So if that Yeah. So so just to expand to expand on the vendor whether, like, we're gonna do, like, entire three s f or a a trim of it. Going with just the full three SF might be easier. So because we we already have the reference implementation. Right? So we can all all implement right away rather than, like, trying to come up with a a a a trimmed out specs or implementation. Oh, I I think Gajinder says Gajinder said. Good with this. So but unless maybe maybe Jin or Jihoon might wanna chime in, or do you agree? Hi, Justin. So Yeah. So 3 ms stock mini has a quite clear spec, and, also, we have Python code, So I think it is very good place to start. But one thing I'd I'd like to notice is that it doesn't have, signature validation or something. So we need to figure out how we can integrate the signatures in the current containers like vote or state. So just to chime in over here. So the 3SF mini that Vitalik has there there will be some modifications that will need on top of it. For example, handling of the Genesis block because in 3SF mini, Genesis is slot one while we generally have Genesis as slot zero. So small additional logic or additional logic that we handle while processing slot one or, basically, the first block. So apart from that, I think we can just adopt it. With regard to signatures, we so, generally, what really happens is that we can basically pass a flag in in the state transition function that says that's the next signatures have been externally validated, which is basically how we will do it because the state transition function will need to be provable. And so is basically running outside the signature aggregation slash proving verification mode there. Basically, those are separately verified and proved. So so, basically, what I'm saying is that we don't have too much about signature validation inside the 3SF. We'll basically there we should assume that there will be a separate validation that will run before block processing starts. For all the signatures that are in the block the block signature as well as attestation signatures or forward, signatures that might be there or for slashing, etcetera. So apart from that, I think we don't really need to worry too much about signature on the DevNet zero, but then DevNet one will have the signature bit into it. So signature will start coming in coming over the role coming into picture over there. Two in a row. Anything to add to that? Are you guys good with that direction? Barnabas, welcome. I see your question. I was actually just noting that we had some open discussion items on this first DevNet spec, I was gonna see if we should get some ETH PandaOps people to join this next call, but you're asking for a TLDR on what's needed for primitive Kurtosis support. You front row. O or Gajinder, maybe could one of you speak to Kurtosis support? Anything else that we might wanna put on radar of the PandaOps?

**Gajinder:** I speak a little bit about it. I think the most primitive thing that will need will be Genesis generator, and the Genesis generator will also need to have the validator keys generated inside it. So zero, obviously, then validated a key generator is not really the concern. But we will basically still generate the Genesis with with that tool and be so, basically, allocate some key references to it at least. Like public key references to it so that validators can be distributed among the nodes. And I then what Kurtosis needs to do is basically spin up spin up the nodes with some delay. And I think that's about it because we don't have any execution linked to it right now. So it will be, like, how phase zero of Beacon chain progressed. And there will be no deposits, etcetera. So all that is something that we don't need to worry about. What kind of keys do you need? Baked into the Genesis? We will just need some key references. I mean, the just be so what we need is that when we will define the Genesis state, it will have some validators array, and each validator will have a pub key hex to it and is actually no need of key public private key over there. It's just a random that you can generate, and so those hex can be distributed among different validator nodes so the so that they just figure out that, okay, you know, I'm validator x, validator one, or validator two or whatever. And, basically, then do their duties according to that. Apart from that, because on DevNet zero, we don't need it. Then on DevNet one, will need to integrate public private key generator will, I think, be quite CPU intensive task. Generate the keys. And that will sort of generate the private keys. And for that, we will also come up with a simple spec of how to generate the key file. Which will not be similar to which will be very different from the beacon key file. Do we need Dora support? I guess we have Dora support. But I don't know But what things we need to sounds like quite some work, to be honest, especially if the evaluator key structure is gonna be different. Because right now, we assume that everything is a BLS key, basically. So Yes. The whole library different libraries. You have multiple libraries that we require to update for this. So yeah, the only way I can see it happening is if you would have a new library that supports this new character key structure, we would add support for basically, picking and choosing whether we want lean Ethereum or a normal Ethereum like, these are keys at polygenesis validator sets. Or we completely Ethereum package, and we work off of that. But yeah, I'm not sure. What what's the best approach is. Yeah. I mean as long as everyone aware about like every other peers then yeah, I think this will work. Yeah. So everyone could still be aware about each other peers and still do some sort of a topology so basically not have a star topology that I think gossip will anyway take care of. So yeah, as you mentioned that if basically the information is there, the should be able to form a good network. Okay. Thanks.

**Barnabas:** Yeah I mean as long as everyone aware about like every other peers then yeah, I think this will work.

**Gajinder:** Yeah, so everyone could still be aware about each other peers and still do some sort of a topology so basically not have a star topology that I think gossip will anyway take care of. So yeah, as you mentioned that if basically the information is there, the should be able to form a good network. Okay. Thanks.

### Spec Repo Updates

**Will:** Great. Well, Welcome to the call. I've got just and, Tamaghna, I've got an overview of the spec repo updates as item three, but maybe we can jump to that real quick if you wanted to just give us an update on the work that you've done and if there's anything that people should know about interacting with that that repo.

**Tamaghna:** If if you want, I can give you brief overview. So basically, we have started, like, to to do a repo that is called Lean spec inside the Lean Ethereum organization. So this is a new repo that has been set up by Felipe with proper packaging Python stuff, and all of these using UV it's really straightforward. You have all of the requirements on the read me that is very simple to follow. You just have to clone and basically install the dependency and run it as too simple, very simple command. So what we have done in this repo is that we have a a source. And inside this source, we have the main lean spec with some subspec. So the goal here is to define first the the very small primitive, like, koala bear and then Poseidon2 and then the signature scheme. So I have made the first PR that has been just merged by Felipe. Just before the call about the koala bear. So in this koala bear subspec folder, you can see that there is a field dot py file you have the very basic specification. We have used for this. That's as a very nice toolings for playing with basic Python object and stuff. So you can check there very basic function. Just if you go to the to the field dot by file, you will see that this is just basic function, just add sub neg and all of this. To set up this. And you have also in the root of the repo test folders when all of the tests of each sub subspec. So that is basically it. This is where we will try to put all of the all of the lean specs as I just mentioned, we will start by doing the koala bear that is done. Now I will do the Poseidon2 spec, and finally, the signature aggregation spec with the help of Benedict and probably above this. Yeah. This is basically all that we you have to know. If you have any question about this, reading the repo or stuff, don't hesitate contact me or or Felipe maybe because he has much more knowledge than me. Everything related to Python and all of the setup So, yeah, don't hesitate, Felipe, if you want to add a word or something. Yeah. Hey. No. I I think you covered it well. I I'm always available if if anyone has any questions. On on the Python side of things or on the setup. I also think there's room for the spec to kind of grow as more, specs are implemented. And so, yeah, if you have any suggestions, feel free as well.

**Will:** Felipe, could you maybe speak to how this is it sounded like the way that you're structuring this is an improvement or an evolution on the current consensus specs?

**Felipe:** No. So the current consensus specs it it kind of, diverged from more traditional, Python, repositories. And so wanted to align a little bit more with the current execution specs state of things. And with the with the execution test specs as well. And so what we put together, here is is basically making use of the modern tooling, that has evolved since, the consensus specs. Repository was was put together. And is more in line with how the execution specs currently exist.

**Will:** Very cool. Thank you.

### Serialization Discussion

**Will:** Alright. So we glossed over item two, which was the fork choice spec discussion. I don't know if there's anything else that needs to be said there. There were I woke up I saw some conversation debating over which direction to go Do people have clarity on that Oh, sorry. Oh, on three s f, Maybe I'm naive, but LMD gWill and three s f mini. Plus proposing block plus voting. I think is almost everything is there in three SF. The remaining justification finalization logic is quite small. So if that Yeah. So so just to expand to expand on the vendor whether, like, we're gonna do, like, entire three s f or a a trim of it. Going with just the full three SF might be easier. So because we we already have the reference implementation. Right? So we can all all implement right away rather than, like, trying to come up with a a a a trimmed out specs or implementation. Oh, I I think Gajinder says Gajinder said. Good with this. So but unless maybe maybe Jin or Jihoon might wanna chime in, or do you agree? Hi, Justin. So Yeah. So 3 ms stock mini has a quite clear spec, and, also, we have Python code, So I think it is very good place to start. But one thing I'd I'd like to notice is that it doesn't have, signature validation or something. So we need to figure out how we can integrate the signatures in the current containers like vote or state. So just to chime in over here. So the 3SF mini that Vitalik has there there will be some modifications that will need on top of it. For example, handling of the Genesis block because in 3SF mini, Genesis is slot one while we generally have Genesis as slot zero. So small additional logic or additional logic that we handle while processing slot one or, basically, the first block. So apart from that, I think we can just adopt it. With regard to signatures, we so, generally, what really happens is that we can basically pass a flag in in the state transition function that says that's the next signatures have been externally validated, which is basically how we will do it because the state transition function will need to be provable. And so is basically running outside the signature aggregation slash proving verification mode there. Basically, those are separately verified and proved. So so, basically, what I'm saying is that we don't have too much about signature validation inside the 3SF. We'll basically there we should assume that there will be a separate validation that will run before block processing starts. For all the signatures that are in the block the block signature as well as attestation signatures or forward, signatures that might be there or for slashing, etcetera. So apart from that, I think we don't really need to worry too much about signature on the DevNet zero, but then DevNet one will have the signature bit into it. So signature will start coming in coming over the role coming into picture over there. Two in a row. Anything to add to that? Are you guys good with that direction? Barnabas, welcome. I see your question. I was actually just noting that we had some open discussion items on this first DevNet spec, I was gonna see if we should get some ETH PandaOps people to join this next call, but you're asking for a TLDR on what's needed for primitive Kurtosis support. You front row. O or Gajinder, maybe could one of you speak to Kurtosis support? Anything else that we might wanna put on radar of the PandaOps?

**Gajinder:** I speak a little bit about it. I think the most primitive thing that will need will be Genesis generator, and the Genesis generator will also need to have the validator keys generated inside it. So zero, obviously, then validated a key generator is not really the concern. But we will basically still generate the Genesis with with that tool and be so, basically, allocate some key references to it at least. Like public key references to it so that validators can be distributed among the nodes. And I then what Kurtosis needs to do is basically spin up spin up the nodes with some delay. And I think that's about it because we don't have any execution linked to it right now. So it will be, like, how phase zero of Beacon chain progressed. And there will be no deposits, etcetera. So all that is something that we don't need to worry about. What kind of keys do you need? Baked into the Genesis? We will just need some key references. I mean, the just be so what we need is that when we will define the Genesis state, it will have some validators array, and each validator will have a pub key hex to it and is actually no need of key public private key over there. It's just a random that you can generate, and so those hex can be distributed among different validator nodes so the so that they just figure out that, okay, you know, I'm validator x, validator one, or validator two or whatever. And, basically, then do their duties according to that. Apart from that, because on DevNet zero, we don't need it. Then on DevNet one, will need to integrate public private key generator will, I think, be quite CPU intensive task. Generate the keys. And that will sort of generate the private keys. And for that, we will also come up with a simple spec of how to generate the key file. Which will not be similar to which will be very different from the beacon key file. Do we need Dora support? I guess we have Dora support. But I don't know But what things we need to sounds like quite some work, to be honest, especially if the evaluator key structure is gonna be different. Because right now, we assume that everything is a BLS key, basically. So Yes. The whole library different libraries. You have multiple libraries that we require to update for this. So yeah, the only way I can see it happening is if you would have a new library that supports this new character key structure, we would add support for basically, picking and choosing whether we want lean Ethereum or a normal Ethereum like, these are keys at polygenesis validator sets. Or we completely Ethereum package, and we work off of that. But yeah, I'm not sure. What what's the best approach is. Yeah. I mean as long as everyone aware about like every other peers then yeah, I think this will work. Yeah. So everyone could still be aware about each other peers and still do some sort of a topology so basically not have a star topology that I think gossip will anyway take care of. So yeah, as you mentioned that if basically the information is there, the should be able to form a good network. Okay. Thanks.

**Barnabas:** Yeah I mean as long as everyone aware about like every other peers then yeah, I think this will work.

**Gajinder:** Yeah, so everyone could still be aware about each other peers and still do some sort of a topology so basically not have a star topology that I think gossip will anyway take care of. So yeah, as you mentioned that if basically the information is there, the should be able to form a good network. Okay. Thanks.

### Communication Channels Consolidation

**Will:** More or less at time, the last item that I had was try to see if we wanted to we've got a couple of you know, like, this effort is starting up organically. We've got some different areas where conversations are taking place. I would love to take the temperature from the group to see if we could go about trying to consolidate that. Right now, we have this PQ interop telegram group. We have a a beam testing telegram group, and then we asked them to create a a a a Discord server or sorry, Discord channel in the EF R&D Discord. There's a lot of I know that people just have preferences on Telegram versus Discord. We could certainly take the two Telegram channels that we have merge them together, create a kind of a mirrored channel of what is on the Discord and add a Discord bot so that there's cross posting there. I've seen it done a bunch of different ways. I'd love to just get some feedback from the group so that we can make sure that more and more consensus devs and contributors are getting visibility on this effort in the ETH r and d Discord, but also don't wanna you know, force people to work in a way that is I guess, counterintuitive. You know, and having any thoughts on how to proceed with this. Or you just want me to make some decisions and run with it? Gajinder says yes to the TG Discord bridge. Okay. So if that works, I'll just create a a new discord or sorry, Telegram group that is sort of meant to be a a mirror of what is on the Discord. It's called post quantum. And I'll I'll work with them to get the Discord bot added to that. And then we'll go about deprecating the the PQ interop telegram group and the beam testers telegram group and everyone just try to funnel conversations into that one new channel. Great. Any last words? We've got one minute. Otherwise, people can oh, we're out of time. We could go to the the livestream. Alright, folks. Take care. I will circulate minutes, shortly.

**Participants:** Bye. You. Thank you. Bye. Thank you guys. Bye.