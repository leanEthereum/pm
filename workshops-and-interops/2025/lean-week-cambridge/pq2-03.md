# pq2-03: Bindings (workshop)

## Categories
- PQ-implementation

## Related Talks
- [pq2-01](pq2-01.md): PQ Ethereum Workshop - Day 2 Kickoff
- [pq2-04](pq2-04.md): Minimal zkVM
- [pq2-11](pq2-11.md): PQ Ethereum Workshop - Day 2 Recap

## Summary
Guillaume Ballet led a workshop on bindings for integrating Rust-based cryptographic libraries (e.g., for PQ signatures like LeanSig, XMSS, and leanVM) with other languages such as Zig, Go, and C++ in Ethereum clients like Zeam, Reth, and others. Participants discussed challenges including long compilation times (e.g., 10-20 minutes for Rust dependencies), memory constraints, duplicate symbols in static libraries, Rust version incompatibilities, and the need for static binaries without shared libraries. Solutions explored included using objcopy to prefix symbols, linker scripts for identical code folding (ICF) and garbage collection, compartmentalizing libraries, distributing precompiled .a files via GitHub artifacts or Git LFS, and eventually porting stable components to C/C++ or other languages for better interoperability. The group emphasized short-term use of Rust reference implementations while planning long-term multi-language ports to avoid bugs, enable GPU acceleration (e.g., via CUDA in C++), and support diverse clients. API designs for LeanSig (keygen, sign, verify) and leanVM (prove, verify, aggregate, merge) were outlined, favoring opaque contexts for thread pools/GPUs and separate verifier repos for lightweight clients. Discussions highlighted the value of multiple implementations for security (e.g., bug resilience like in MLS) and reproducible builds via Nix, despite its issues.

## Key Takeaways
- Rust integration poses compilation and compatibility challenges; solutions like objcopy for symbol prefixing and linker scripts can mitigate duplicates in static libraries.
- Short-term: Use Rust refs with precompiled .a files or processes over sockets; long-term: Port stable crypto (e.g., Poseidon, fields, XMSS) to C/C++/Zig/Go for interoperability and GPU support.
- Multiple implementations enhance security and bug detection; aim for 2-3 per primitive until formal verification.
- APIs should be simple (e.g., opaque contexts for init/prove/verify) to hide implementation details and support CPU/GPU; separate lightweight verifiers for resource-constrained devices.
- Reproducible builds (e.g., via Nix) and supply chain security are crucial; explore alternatives if Nix issues persist.

## Speakers
- [Guillaume Ballet](https://x.com/gballet) (Zeam - lean client)

## Resources
- Slides: none provided
- [Video](https://youtu.be/J9KPje1j0XY)

> back to: [Index Page](index.md)

*Note: Summaries were generated in part with the help of AI, so names and terms may not be 100% accurate.*