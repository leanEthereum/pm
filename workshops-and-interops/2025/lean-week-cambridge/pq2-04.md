# pq2-04: Minimal zkVM

## Categories
- leanVM
- formal verification

## Related Talks
- [pq2-01](pq2-01.md): PQ Ethereum Workshop - Day 2 Kickoff
- [leanVM-01](leanVM-01.md): leanVM Crash Course & Sumcheck Optimization
- [pq2-05](pq2-05.md): e2e Formal Verification
- [pq2-11](pq2-11.md): PQ Ethereum Workshop - Day 2 Recap

## Summary
Emile presented the minimal zkVM for Lean Ethereum, designed for aggregating and merging XMSS signatures using Poseidon2 hashes and recursive SNARKs in a single program. Discussions covered architecture choices: KoalaBear base field (p=2^31-2^24+1) for efficiency (fewer Poseidon rounds, x^3 automorphism), extension degree 5-6 for security. Read-only memory (ROM) model simplifies proving (no allocation pointer like Cairo), using frame-relative addressing and dereferences for data flow. ISA includes ADD/MUL (arithmetic), DEREF (memory access), JUMP (control flow with hints), and precompiles (Poseidon16/24, dot product, multilinear eval) for performance. Benchmarks showed ~500 XMSS aggregations in ~1s on CPU, with optimizations like LogUp lookups, JachPCS for packing AIR columns into one Reed-Solomon code (reducing commitments), and multivariate techniques. Debates on read-only vs read-write memory highlighted UX trade-offs, control flow handling, and alternatives like binary fields (slower per experiments). Formal verification via ArkLib noted; recursion and full XMSS integration pending. Attendees suggested API refinements, GPU synergies, and circuit-based alternatives for simplicity.

## Key Takeaways
- zkVM unifies XMSS aggregation/merging in one program over KoalaBear field, prioritizing CPU efficiency; binary fields slower based on Jan 2025 benchmarks.
- Read-only memory and minimal ISA (4 opcodes + precompiles) enable efficient proving via LogUp and JachPCS, packing AIR into one RS code to cut commitments by ~1/3.
- No allocation pointer simplifies design; functions via JUMP with hints, enabling recursion without continuations; benchmarks target <1s for 500 aggregations.
- Debates: Read-only suits specialized use (no Turing-completeness needed), but circuits or read-write could simplify for broader apps; formal verification key for trust.
- Optimizations: Multivariate over univariate for fewer columns (~8-9 vs 150-200); future GPU/NEON for precompiles; separate verifier repo for light clients.

## Speakers
- Emile (EF grantee)

## Resources
- [Slides](https://drive.google.com/file/d/13ciZ3byilokIbNp_6po-byed8qWHQAtI/view?usp=drive_link)
- [Video](https://youtu.be/DH-r1EEyAaI)

> back to: [Index Page](index.md)

*Note: Summaries were generated in part with the help of AI, so names and terms may not be 100% accurate.*